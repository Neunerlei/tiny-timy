#!/usr/bin/env bash
# This script was generated by bashly 1.1.2 (https://bashly.dannyb.co)
# Modifying it manually is not recommended

# :wrapper.bash3_bouncer
if [[ "${BASH_VERSINFO:-0}" -lt 4 ]]; then
  printf "bash version 4 or higher is required\n" >&2
  exit 1
fi

# :command.master_script

# :command.version_command
version_command() {
  echo "$version"
}

# :command.usage
env_usage() {
  if [[ -n $long_usage ]]; then
    printf "env - Environment Control application\n"
    echo

  else
    printf "env - Environment Control application\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  env COMMAND\n"
  printf "  env [COMMAND] --help | -h\n"
  printf "  env --version | -v\n"
  echo
  # :command.usage_commands
  printf "%s\n" "Commands:"
  printf "  %s   similar to docker-compose up, but sets all the required environment variables for buildkit. (All docker command options are valid)\n" "up         "
  printf "  %s   simple alias to docker-compose stop\n" "stop       "
  printf "  %s   simple alias to docker-compose down\n" "down       "
  printf "  %s   removes the existing container image\n" "clean      "
  printf "  %s   allows you to run tests against the current codebase\n" "test       "
  printf "  %s   runs a certain composer command for the project\n" "composer   "
  printf "  %s   builds the docker image for local testing\n" "build      "
  printf "  %s   rebuilds the bashly application you are currently using, based on the sources\n" "rebuild-cli"
  printf "  %s   basically your docker-compose exec into the main app container\n" "ssh        "
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo
    printf "  %s\n" "--version, -v"
    printf "    Show version number\n"
    echo

  fi
}

# :command.usage
env_up_usage() {
  if [[ -n $long_usage ]]; then
    printf "env up - similar to docker-compose up, but sets all the required environment variables for buildkit. (All docker command options are valid)\n"
    echo

  else
    printf "env up - similar to docker-compose up, but sets all the required environment variables for buildkit. (All docker command options are valid)\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  env up [OPTIONS] [...]\n"
  printf "  env up --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--attach, -f"
    printf "    By default, the containers are started daemonized, use this to attach to\n    their output\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
env_stop_usage() {
  if [[ -n $long_usage ]]; then
    printf "env stop - simple alias to docker-compose stop\n"
    echo

  else
    printf "env stop - simple alias to docker-compose stop\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  env stop [...]\n"
  printf "  env stop --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
env_down_usage() {
  if [[ -n $long_usage ]]; then
    printf "env down - simple alias to docker-compose down\n"
    echo

  else
    printf "env down - simple alias to docker-compose down\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  env down [...]\n"
  printf "  env down --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
env_clean_usage() {
  if [[ -n $long_usage ]]; then
    printf "env clean - removes the existing container image\n"
    echo

  else
    printf "env clean - removes the existing container image\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  env clean [OPTIONS]\n"
  printf "  env clean --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--yes, -y"
    printf "    Don't ask just do...\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
env_test_usage() {
  if [[ -n $long_usage ]]; then
    printf "env test - allows you to run tests against the current codebase\n"
    echo

  else
    printf "env test - allows you to run tests against the current codebase\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  env test COMMAND\n"
  printf "  env test [COMMAND] --help | -h\n"
  echo
  # :command.usage_commands
  printf "%s\n" "Commands:"
  printf "  %s   runs the unit test cases\n" "unit"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
env_test_unit_usage() {
  if [[ -n $long_usage ]]; then
    printf "env test unit - runs the unit test cases\n"
    echo

  else
    printf "env test unit - runs the unit test cases\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  env test unit [OPTIONS] [...]\n"
  printf "  env test unit --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--coverage, -c"
    printf "    Generates a coverage report\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
env_composer_usage() {
  if [[ -n $long_usage ]]; then
    printf "env composer - runs a certain composer command for the project\n"
    echo

  else
    printf "env composer - runs a certain composer command for the project\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  env composer [...]\n"
  printf "  env composer --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
env_build_usage() {
  if [[ -n $long_usage ]]; then
    printf "env build - builds the docker image for local testing\n"
    echo

  else
    printf "env build - builds the docker image for local testing\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  env build\n"
  printf "  env build --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
env_rebuild_cli_usage() {
  if [[ -n $long_usage ]]; then
    printf "env rebuild-cli - rebuilds the bashly application you are currently using, based on the sources\n"
    echo

  else
    printf "env rebuild-cli - rebuilds the bashly application you are currently using, based on the sources\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  env rebuild-cli\n"
  printf "  env rebuild-cli --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
env_ssh_usage() {
  if [[ -n $long_usage ]]; then
    printf "env ssh - basically your docker-compose exec into the main app container\n"
    echo

  else
    printf "env ssh - basically your docker-compose exec into the main app container\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  env ssh [OPTIONS]\n"
  printf "  env ssh --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--cmd, -c COMMAND"
    printf "    By default, we will use \"bash\" as command, you can use \"sh\" or any other\n    command if you want to\n"
    printf "    Default: bash\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.normalize_input
normalize_input() {
  local arg flags

  while [[ $# -gt 0 ]]; do
    arg="$1"
    if [[ $arg =~ ^(--[a-zA-Z0-9_\-]+)=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^(-[a-zA-Z0-9])=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^-([a-zA-Z0-9][a-zA-Z0-9]+)$ ]]; then
      flags="${BASH_REMATCH[1]}"
      for ((i = 0; i < ${#flags}; i++)); do
        input+=("-${flags:i:1}")
      done
    else
      input+=("$arg")
    fi

    shift
  done
}
# :command.inspect_args
inspect_args() {
  if ((${#args[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!args[@]}" | sort)
    echo args:
    for k in "${sorted_keys[@]}"; do echo "- \${args[$k]} = ${args[$k]}"; done
  else
    echo args: none
  fi

  if ((${#other_args[@]})); then
    echo
    echo other_args:
    echo "- \${other_args[*]} = ${other_args[*]}"
    for i in "${!other_args[@]}"; do
      echo "- \${other_args[$i]} = ${other_args[$i]}"
    done
  fi

  if ((${#deps[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!deps[@]}" | sort)
    echo
    echo deps:
    for k in "${sorted_keys[@]}"; do echo "- \${deps[$k]} = ${deps[$k]}"; done
  fi

}

# :command.user_lib
# _env/src/lib/dockerUtil.sh
determineDockerExecutable(){
  local dockerExecutable=$(which docker)
  if [[ ${dockerExecutable} ]]; then
    echo ${dockerExecutable}
    return
  fi
  local podmanExecutable=$(which podman)
  if [[ ${podmanExecutable} ]]; then
    echo ${podmanExecutable}
    return
  fi
  echo "Sorry, but I did not find docker or podman on your system" >&2
  exit 1
}

determineDockerComposeExecutable() {
  # Special switch for pod-man
  PODMAN_PATH=$(which podman-compose)
	if [[ ${PODMAN_PATH} ]]; then
		echo ${PODMAN_PATH}
		return
	fi
  PODMAN_PATH=$(which podman)
	if [[ ${PODMAN_PATH} ]]; then
		echo ${PODMAN_PATH} compose
		return
	fi

	COMPOSE_PATH=$(which docker-compose)

	# Check if some WSL weirdness is going on
	if [[ ${COMPOSE_PATH} ]] && [[ ${COMPOSE_PATH} != /mnt/* ]]; then
		# No wsl weirdness is going on -> return the path as is...
		echo ${COMPOSE_PATH}
		return
	fi

	COMPOSE_VERSION=$(docker compose version)

	if [[ ${COMPOSE_VERSION} == *v2* ]]; then
		echo "docker compose"
		return
	fi

  echo "Sorry, but I did not find docker-compose or 'docker compose' on your system" >&2
  exit 1
}

determineDockerRuntimeType(){
  local composeExecutable=$(determineDockerComposeExecutable)
  if [[ ${composeExecutable} == *podman* ]]; then
    echo "podman"
    return
  fi
  echo "docker"
}

provideDockerEnvironmentVariablesBasedOnRuntimeType(){
  echo "export BUILDKIT_PROGRESS=plain"
  echo "export COMPOSE_DOCKER_CLI_BUILD=1"
  echo "export DOCKER_BUILDKIT=1"

  if [[ ${DOCKER_RUNTIME_TYPE} == "podman" ]]; then
    echo "export DOCKER_RUNTIME=podman"
    echo "export DOCKER_USER=root"
  else
    echo "export DOCKER_RUNTIME=docker"
    echo "export DOCKER_USER=${DEFAULT_UID}:${DEFAULT_GID}"
    echo "export DOCKER_UID=${DEFAULT_UID}"
    echo "export DOCKER_GID=${DEFAULT_GID}"
  fi
}

isDockerContainerRunning(){
  local containerName=${1:-${DEFAULT_CONTAINER_NAME}}
  local containerId=$($DOCKER_EXECUTABLE ps -q -f name=${containerName})
  if [[ ${containerId} ]]; then
    return 0
  fi
  return 1
}

# _env/src/lib/phpUtil.sh
areComposerDependenciesInstalled(){
  if [ -f ${PROJECT_ROOT_DIR}/vendor/autoload.php ]; then
    return
  fi

  false
}

# _env/src/lib/util.sh
# Loads the script environment file or dies if it does not exist
loadEnvFile(){
  ENV_FILE=${ENV_FILE:-"${PROJECT_ROOT_DIR}/.env"}

  if [ ! -f ${ENV_FILE} ]; then
    echo "Missing ${ENV_FILE} file! Please copy .env.tpl, rename it to .env and add the required values before continuing!";
    exit 1;
  fi

  source ${ENV_FILE}
}

# Asserts that the provided command exist, or kills the script
assertCommandExists(){
  MESSAGE=${2:-"Error: the required executable ${1} does not exist"}
  if ! [ -x "$(command -v $1)" ]; then
    echo "${MESSAGE}" >&2
    exit 1
  fi
}

# Asks the user for confirmation and assumes yes should be the default answer
confirmDefaultYes(){
  QUESTION=${1:-"Are you sure?"}
  read -r -p "${QUESTION} [Y/n] " RESPONSE
  RESPONSE=${RESPONSE,,}

  if [[ "${RESPONSE}" =~ ^(yes|y)$ ]] || [[ ${RESPONSE} == "" ]]; then
    return
  fi

  false
}

# Asks the user for confirmation and assumes no should be the default answer
confirmDefaultNo(){
  QUESTION=${1:-"Are you sure?"}
  read -r -p "${QUESTION} [y/N] " RESPONSE
  RESPONSE=${RESPONSE,,}

  if [[ "${RESPONSE}" =~ ^(no|n)$ ]] || [[ ${RESPONSE} == "" ]]; then
  	false
    return
  fi
}

# Checks the last exit code and kills the script if it is bigger than 0
checkLastExitCodeOrDie(){
  CODE=${1:-$?}
  MESSAGE=${2:-"There was an issue with running a task"}

  if [ ${CODE} -ne 0 ]
  then
    echo "${MESSAGE}" >&2
    exit 1
  fi
}

determineHostType() {
  OS='unsupported';
  case "$OSTYPE" in
    #darwin*)  OS="OSX" ;;
    linux*)   OS="LINUX" ;;
    msys*)    OS="WINDOWS" ;;
    cygwin*)  OS="WINDOWS" ;;
  esac

  echo $OS
  return
}

determineOsPlatform() {
  if [[ $OS_TYPE == 'LINUX' ]]; then
    echo $(dpkg --print-architecture)
    return
  fi

  if [[ $OS_TYPE == 'WINDOWS' ]]; then
    echo %PROCESSOR_ARCHITECTURE%
    return
  fi
}

isWslMachine() {
  if [[ $(grep Microsoft /proc/version) ]]; then
    return
  fi
  if [[ $(grep microsoft /proc/version) ]]; then
    return
  fi

  false
}

# :command.command_functions
# :command.function
env_up_command() {
  # _env/src/up_command.sh
  ARGS=${other_args[*]}

  if ! [ ${args[--attach]} ]; then
  	ARGS+=" -d"
  fi

  $DOCKER_COMPOSE_EXECUTABLE up $ARGS

}

# :command.function
env_stop_command() {
  # _env/src/stop_command.sh
  ${DOCKER_COMPOSE_EXECUTABLE} stop ${other_args[*]}

}

# :command.function
env_down_command() {
  # _env/src/down_command.sh
  ${DOCKER_COMPOSE_EXECUTABLE} down ${other_args[*]}

}

# :command.function
env_clean_command() {
  # _env/src/clean_command.sh
  if [[ ${args[--yes]} ]] || confirmDefaultYes 'Should really remove the image build for this project from your disk?';
  then
    run stop
    if [[ ${DOCKER_RUNTIME_TYPE} == 'docker' ]]; then
      ${DOCKER_COMPOSE_EXECUTABLE} down --rmi all --volumes
  	  ${DOCKER_COMPOSE_EXECUTABLE} rm --force --stop --volumes
    else
     ${DOCKER_COMPOSE_EXECUTABLE} down
    fi
  fi

}

# :command.function
env_test_unit_command() {
  # _env/src/test_unit_command.sh
  if ! areComposerDependenciesInstalled ; then
    run composer install
  fi

  if [[ ${args[--coverage]} ]]; then
    run ssh -c "composer run test:unit:coverage"
  else
    run ssh -c "composer run test:unit"
  fi

}

# :command.function
env_composer_command() {
  # _env/src/composer_command.sh
  CMD="${other_args[*]}"

  if [[ "${CMD}" == install* || "${CMD}" == update* || "${CMD}" == require* || "${CMD}" == remove* ]]; then
    CMD="${CMD} --ignore-platform-req=ext-memcached"
  fi

  run ssh -c "composer ${CMD}"

}

# :command.function
env_build_command() {
  # _env/src/build_command.sh
  SERVICE_NAME=app
  $DOCKER_COMPOSE_EXECUTABLE build ${SERVICE_NAME}

}

# :command.function
env_rebuild_cli_command() {
  # _env/src/rebuild_cli_command.sh
  if confirmDefaultYes "This will regenerate the bin/env script, based on the sources under bin/_env! Are you sure you want to continue?";
  then
    echo "Okay, lets do this...";
  else
    echo "Okay, aborting!";
    exit
  fi

  ${BASH_SOURCE%/*}/_env/bashly.sh generate
}

# :command.function
env_ssh_command() {
  # _env/src/ssh_command.sh
  if ! isDockerContainerRunning; then
    run up
  fi

  $DOCKER_EXECUTABLE exec -ti ${DEFAULT_CONTAINER_NAME} ${args[--cmd]:-bash}

}

# :command.parse_requirements
parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --version | -v)
        version_command
        exit
        ;;

      --help | -h)
        long_usage=yes
        env_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    up)
      action="up"
      shift
      env_up_parse_requirements "$@"
      shift $#
      ;;

    stop)
      action="stop"
      shift
      env_stop_parse_requirements "$@"
      shift $#
      ;;

    down)
      action="down"
      shift
      env_down_parse_requirements "$@"
      shift $#
      ;;

    clean)
      action="clean"
      shift
      env_clean_parse_requirements "$@"
      shift $#
      ;;

    test)
      action="test"
      shift
      env_test_parse_requirements "$@"
      shift $#
      ;;

    composer)
      action="composer"
      shift
      env_composer_parse_requirements "$@"
      shift $#
      ;;

    build)
      action="build"
      shift
      env_build_parse_requirements "$@"
      shift $#
      ;;

    rebuild-cli)
      action="rebuild-cli"
      shift
      env_rebuild_cli_parse_requirements "$@"
      shift $#
      ;;

    ssh)
      action="ssh"
      shift
      env_ssh_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      env_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
env_up_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        env_up_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="up"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --attach | -f)

        # :flag.case_no_arg
        args['--attach']=1
        shift
        ;;

      --)
        shift
        other_args+=("$@")
        break
        ;;

      -?*)
        other_args+=("$1")
        shift
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_catch_all
        other_args+=("$1")
        shift

        ;;

    esac
  done

}

# :command.parse_requirements
env_stop_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        env_stop_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="stop"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      --)
        shift
        other_args+=("$@")
        break
        ;;

      -?*)
        other_args+=("$1")
        shift
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_catch_all
        other_args+=("$1")
        shift

        ;;

    esac
  done

}

# :command.parse_requirements
env_down_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        env_down_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="down"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      --)
        shift
        other_args+=("$@")
        break
        ;;

      -?*)
        other_args+=("$1")
        shift
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_catch_all
        other_args+=("$1")
        shift

        ;;

    esac
  done

}

# :command.parse_requirements
env_clean_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        env_clean_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="clean"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --yes | -y)

        # :flag.case_no_arg
        args['--yes']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
env_test_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        env_test_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    unit)
      action="unit"
      shift
      env_test_unit_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      env_test_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
env_test_unit_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        env_test_unit_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="test unit"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --coverage | -c)

        # :flag.case_no_arg
        args['--coverage']=1
        shift
        ;;

      --)
        shift
        other_args+=("$@")
        break
        ;;

      -?*)
        other_args+=("$1")
        shift
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_catch_all
        other_args+=("$1")
        shift

        ;;

    esac
  done

}

# :command.parse_requirements
env_composer_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        env_composer_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="composer"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      --)
        shift
        other_args+=("$@")
        break
        ;;

      -?*)
        other_args+=("$1")
        shift
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_catch_all
        other_args+=("$1")
        shift

        ;;

    esac
  done

}

# :command.parse_requirements
env_build_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        env_build_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="build"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
env_rebuild_cli_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        env_rebuild_cli_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="rebuild-cli"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
env_ssh_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        env_ssh_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="ssh"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --cmd | -c)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--cmd']="$2"
          shift
          shift
        else
          printf "%s\n" "--cmd requires an argument: --cmd, -c COMMAND" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

  # :command.default_assignments
  [[ -n ${args['--cmd']:-} ]] || args['--cmd']="bash"

}

# :command.initialize
initialize() {
  version="1.0.0"
  long_usage=''
  set -e

  # _env/src/initialize.sh
  PROJECT_ROOT_DIR=$(realpath ${BASH_SOURCE%/*}/..)

  OS_TYPE=$(determineHostType)

  if [[ $OS_TYPE == 'unsupported' ]]; then
    echo 'Sorry, but we currently don''t support your operating system!'
    exit 1
  fi

  OS_PLATFORM=$(determineOsPlatform)

  loadEnvFile

  DOCKER_EXECUTABLE=$(determineDockerExecutable)
  DOCKER_COMPOSE_EXECUTABLE=$(determineDockerComposeExecutable)
  DOCKER_RUNTIME_TYPE=$(determineDockerRuntimeType)

  DEFAULT_SERVICE_NAME=${SERVICE_NAME:-app}
  DEFAULT_CONTAINER_NAME="${PROJECT_NAME:-project-without-name}-${DEFAULT_SERVICE_NAME}"
  DEFAULT_UID=${ENV_UID:-$(id -u)}
  DEFAULT_GID=${ENV_GID:-$(id -g)}

  $(provideDockerEnvironmentVariablesBasedOnRuntimeType)

}

# :command.run
run() {
  declare -A args=()
  declare -A deps=()
  declare -a other_args=()
  declare -a input=()
  normalize_input "$@"
  parse_requirements "${input[@]}"

  case "$action" in
    "up") env_up_command ;;
    "stop") env_stop_command ;;
    "down") env_down_command ;;
    "clean") env_clean_command ;;
    "test") env_test_command ;;
    "test unit") env_test_unit_command ;;
    "composer") env_composer_command ;;
    "build") env_build_command ;;
    "rebuild-cli") env_rebuild_cli_command ;;
    "ssh") env_ssh_command ;;
  esac
}

initialize
run "$@"
